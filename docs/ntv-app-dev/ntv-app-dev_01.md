# 第一部分：任务与操作

在本部分中，我们提供了执行移动应用程序常见任务的基础代码，如显示 UI、传递数据、发送和接收事件、进行网络请求和处理网络响应、访问和操作文件系统，以及读取或写入到偏好或数据库等持久存储。

# 关于移动开发现状的一点说明

在撰写本文时，Android 和 iOS 开发的状态非常动态、高度分散和高度有争议。已添加了用作现有 API 替代品的新库，但其中一些发布并非必然是社区共识的产物。此外，几乎每个替代 API 都比其替代品复杂得多。在决定在本书中包含哪些信息时，包括像库和 API 这样的基础设施，我们决定应尽可能为尽可能多的人和项目提供最大的帮助。大多数开发工作是功能开发和维护，而不是全新的开发项目。考虑到这一点，在几乎所有情况下，我们默认选择一个现有的、经过验证的库，而不是仅有相对较短时间（大约一年是我们决定的任意门槛）可用的新库或做法。

另外，我们发现许多替代 API 使得框架与现有技术中的模式更为远离。例如，Android 上的新的`Navigation`组件集可以用来管理 UI，以与本书中展示的基本方式（`Fragment` 实例）相同，但实现方式却大相径庭。考虑到所需的基础设施数量，与我们认为代表 Android 开发现状的经过验证的模式相比，包含额外的复制和代码来介绍这些模式，可能会弊大于利。另一个很好的例子是数据库技术：最近，Google 推荐 Android 开发使用其 Room 库，但 SQLite API 已包含在 AOSP 的标准库中。没有人会认为 SQLite 没有限制，并且 Room 可能是更现代的方法，但本书的主要目标之一是提供源材料，使通常掌握一般编程的人能够迅速达到高效的流利水平，而 SQL 通常是世界上最常见、最成熟和最广泛应用的技术之一。Room 则不是；因此，我们的数据持久化参考使用 SQLite API。如果您选择使用 Room，那很好！我们鼓励您查看这些更新的推荐和工具，并在适当的时候提及它们，但我们使用`FragmentManager`而不是使用`Navigation` API 所需的组件列表，这显然是一个故意的决定，我们相信这是*目前*的正确选择。

同样地，为了充分利用您作为读者可能具有的现有领域知识，我们可能会使用一种效率较低但更易读或更常见的模式或方法。例如，在 Android 上从流中读取时，我们经常只使用`InputStream.read`而不使用缓冲区；尽管缓冲区显然是适当的，但我们不仅可以实现非常小且易于消化的示例代码块，还可以免去解释缓冲区工作方式（输入和输出两端）、在各种情况下选择何种大小的缓冲区以及预分配单个缓冲区可能比每次读取或写入操作都创建一个新的缓冲区更有效等问题。流缓冲区可能看起来是一个非常简单的概念，但要*正确且完整地*解释它并不是件容易的事情。出于类似的原因，Java 的现代版本提供了针对`Closable`操作的 try-with-resources，但在这种情况下，熟悉其他语言（例如 JavaScript）中 try-catch 的人会立即识别标准语法，并能够集中精力在我们描述的任务上，而不需要停下来处理 try-with-resources 的替代语法，也不需要阅读一两段与*完成任务*目标无关的内容。当然，try-with-resources 在很多情况下都非常适用，我们鼓励每个人在自己的时间里尽可能多地了解每种语言和框架，但本书的目的是让程序员*编程*，而不是掌握我们在本书中涉及的每一项技术。

感谢您的倾听，并感谢所有表达意见的人，这些意见促成了这篇笔记，我们真诚地感激您的体贴。
