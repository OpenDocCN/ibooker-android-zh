# 第八章：并发性（多线程）

并发性，有时也称为并行性或多线程，是同时执行多个任务的概念，将计算机资源划分为不同的实体，这些实体非常快地在彼此之间交替，直到任何实体完成其整个工作负载，此时它将从此过程中移除。计算在不同进程（小写 p）之间跳转的行为被称为“上下文切换”，在计算机科学中具有更常见且非常不同的定义（将你的大脑资源从一个领域切换到另一个领域）。

# 任务

在本章中，您将学习：

1.  在后台线程执行任务。

1.  在主线程上对后台线程执行的工作结果进行操作。

# Android

在 Java 中，处理上下文被称为 `Thread`。`Thread` 是一个对象实例，并且被创建正如你所期望的那样：

一个 `Thread` 实例被传递给一个 `Runnable` 实例。一旦线程启动（通过调用 `start` 方法），线程将调用该 `Runnable` 的 `run` 方法。一旦该方法完成（通过返回或抛出异常），线程终止。

在 Android 中，默认情况下有一个 `Thread` 实例，所有工作都在其上执行，包括并尤其是 UI 工作。这非常重要——事实上，这个概念有时被称为“UI 线程”，但更常被称为“主”线程。从 Android 首次发布到本文撰写时，主线程每秒绘制屏幕 60 次——大约每 16 毫秒一次，并称为“帧”。这是一个极其消耗资源的过程，我们绝对必须允许系统尽可能地获得足够的资源来完成这项工作。因此，极其消耗计算资源的任务应该在“非”主线程上完成（意味着在任何其他线程上；像这样一个*不*负责 UI 或程序原始运行的线程有时被称为“后台线程”）。任何 I/O 工作，如文件系统访问或数据库事务，都应该在后台线程中完成，而像网络请求这样的长时间操作也应该在主线程之外完成。事实上，如果在主线程上执行网络请求等明显的操作，您可能会看到错误或警告。此外，当主线程执行过多工作时，您会在 UI 中看到“卡顿”。例如，`RecyclerView` 可能会不均匀滚动，或者屏幕可能会冻结一段时间。Android Studio 很友好地在 Logcat 中警告我们；您经常会看到如下消息：

> I/Choreographer(1234): 跳过了 20 帧！应用程序可能在其主线程上执行了过多的工作。

这意味着系统尝试*二十次*绘制您的 UI，但由于缺乏必要的资源而无法执行。

## 在后台线程执行任务

那么我们如何在主线程之外进行工作呢？实际上很简单。正如我们所描述的，创建一个新的`Thread`实例，在传递给构造函数的`Runnable`实例的`run`方法中执行一些工作，并通过调用`start`来启动它：

就是这样！还有一些帮助管理`Thread`的类，包括`ThreadPoolExecutor`和`Executors`静态帮助函数（通常返回预配置的`ThreadPoolExecutor`实例）。线程池的好处在于你可以精确控制在任何时间后台发生的工作量，并且可以在任务请求和完成时排队和删除任务。查看[ThreadPoolExecutor](https://oreil.ly/9pV5G)和[Executors](https://oreil.ly/WKIRY)的开发者文档获取更多信息。

你可能听说过并发是计算机科学中最难掌握的东西之一，我们不会假装这里没有一些非常复杂的概念存在，但大多数情况下这些概念都是在幕后由系统提供的，或者可以轻松避免的。迈克曾经说过，“线程很容易；同步很难。” 这意味着，正如我们所看到的，通过后台线程启动一些工作是相当简单的，但在这个陈述中有大约 3500 个星号附加（请原谅这种夸张）。例如，在 Android 框架中，除了在主线程上，你不能访问任何`View`实例。这是一件大事！在前面示例中传递的`Runnable.run`方法中，你甚至不能*引用* `View` 实例，否则会抛出`RuntimeException`。此外，你无法保证多个后台线程的解决顺序；这就是我们开始深入讨论并发问题的地方——你的 Java 生成的字节码并不总是完全像你编写的 Java 代码一样。

典型的“不安全”线程示例可能如下：

根据你的硬件和环境，确切的并发任务数量可能需要更高（或更低）以看到效果，但玩弄基本任务，迟早会看到一个*不是* 9,999 的最终日志。虽然没有花费大量时间在线程安全性的细节上，但我们知道递增运算符的字节码在转换为字节码时可能看起来像这样：

1.  从内存中获取`mCounter`的值。

1.  将`mCounter`的值加 1。

1.  将`mCounter`的值写回内存。

由于并发线程快速切换以模拟同时操作（这称为“上下文切换”），线程 #391 可能在线程 #390 执行步骤 1 和 2 之间读取值。这个具体的例子被称为竞态条件，这个问题通常被称为线程干扰或线程交错，并且是*线程安全*的*缺失*的一个例子。这远非对并发编程危险的全面考察 - Java 的一些实现允许单个线程复制变量以避免昂贵的 IPC（进程间通信）调用，因此当多个线程变异单个对象实例时，状态不能被保证。

有一些机制可以避免这种情况，例如 `synchronized` 和 `volatile` 关键字，以及 `Atomic` 类，由于数据结构特别容易受到影响（想象一个线程在循环遍历数据结构时，另一个线程在添加或删除项目），因此存在多种线程安全（但性能较低）版本的几种数据结构或辅助方法，以减轻这种威胁。

话虽如此，在本章的范围之外，这是一个良好的多线程编程的领域。即使在单个技术栈中，掌握多线程编程可能需要多年时间，有些开发人员甚至永远无法真正理解底层发生了什么 - 在许多情况下，这是完全合适的！出色的 UI 程序员可能会以非常不同的方式使用并发编程，与处理大数据的程序员完全不同。在 Android 框架中的一个简单技巧是在后台线程上执行计算，然后将这些结果通过 `Activity.runOnUiThread`、`View.post` 或 `Handler.post` 发送回主线程，从而确保串行执行并免于其他进程的竞争。

## 在主线程上执行后台线程中执行的工作结果

正如刚才提到的，每当您更新用户界面以反映某些后台线程操作的结果时（这是非常常见的情况 - 您可能需要从本地数据库、远程服务器、文件系统等获取数据），您需要在引用任何 `View` 实例之前返回到主/UI 线程。甚至在 `View` 类之外，更新常见对象到单个线程（主线程）上也很有帮助，以避免前面描述的同步问题。

有三种主要方法可以从后台线程发送消息到主线程：

1.  `View.post` 方法将接受一个 `Runnable` 实例，并在主线程上调用该实例的 `run` 方法。

1.  `Activity.runOnUiThread` 函数几乎与 `View.post` 函数相同，但首先会检查调用是否已经在主线程上进行 - 如果是，则会立即调用 `run` 方法，而不是将其发布到消息队列的末尾（请参见下面的代码）。

1.  `Handler`实例将向其关联的`Looper`中`post`消息，因此使用`new Handler(Looper.getMainLooper())`创建的`Handler`将在主线程上发布消息。同样，该方法接受一个`Runnable`实例，并调用该实例的`run`方法。请注意，除非直接从 UI 线程调用`Activity.runOnUiThread`，否则这两个前述操作实际上都会在此处结束。

下面是一个简单的示例：

## 终止线程

再次强调，这是一个有争议的话题，也许缺乏共识。通常，线程将在完成其工作（当`Runnable`的`run`方法通常返回时）时终止。然而，经常希望过早停止后台线程。例如，如果用户开始下载一个可能有几百兆字节的大视频剪辑，几分钟后可能会决定不值得占用带宽或空间并终止下载。

如果您在自己的线程中执行相同的过程并使用某些第三方下载器库，其中有一个原子的`download`方法，将无法中断：

`Thread`类还有一个被废弃的方法叫做`stop`，但不建议使用，将来可能会从标准库中删除。

`join`方法经常吸引那些学习`Thread` API 的人，但它常常被误解。截至本文撰写时，Java 8 文档解释了`join`方法如下：

> 这个实现使用了一个循环的`this.wait`调用，条件是`this.isAlive`。当线程终止时，将调用`this.notifyAll`方法。建议应用程序不要在`Thread`实例上使用`wait`、`notify`或`notifyAll`。

这可能会*看起来*像线程功能终止了，特别是在处理“主”线程或 UI 线程时，但实际上它仍然在内存中，并继续保持所有引用可达，直到调用该方法的线程本身终止。因此，在使用 UI 线程作为默认上下文的 Android 中，如果启动一个“后台”线程并对其调用`join`，它会存在，但只是在主线程终止（通常是应用程序的结尾或资源回收）之前继续旋转。由于这通常涉及整个进程的崩溃，您可能甚至注意不到后台线程，但要知道它*确实*还在那里，保持引用（内存泄漏）并旋转直到程序本身退出。

还有另一个非常被误解的`Thread`类方法叫做`interrupt`，但这并不是大多数人所认为的。它只是在线程上设置一个布尔标志；在调用`interrupt`之前，调用`isInterrupted`将返回`false`。在调用`interrupt`之后，调用将返回`true`。*仅仅通过`interrupt`无法停止`Thread`的操作*。

这个 API 几乎是按照一个约定来创建的；库的编写者应定期检查`isInterrupted`，并在其为真时`throw`一个`Exception`或立即返回，*但这并不是任何方式的保证*。我们*希望*`Downloader`库的作者这样做了，并且这样做是有意义的，但我们不能确定，这可能意味着您需要自己处理这些复杂的任务。例如，再次以下载为例，您可能希望在每次`InputStream.read`/`OutputStream.write`循环中检查`isInterrupted`。例如，让我们参考 Networking 中的简单下载方法，并修改以支持取消：

在执行`downloadBinaryData`操作的`try/catch`块中，您可能希望删除部分写入的文件，并可能更新 UI 以隐藏进度或向用户显示状态。您可能还希望有一个`cancel`方法，该方法会在后台线程上调用`Thread.interrupt()`。类似这样（修改为适用于 Android 并稍作修饰）可能会起到作用：

[RxJava](https://oreil.ly/HyJnl)库提供了一套强大的 API 来处理并发工作，通过抽象层分离开发代码与低级线程不安全性的风险。这可以是一个很好的工具，帮助您的团队快速掌握，并共享一个通用的代码库，非常适合许多人。不过，与大多数抽象一样，您将在标准库类（如`Thread`）中找到最精细的控制。

Android 框架中的`AsyncTask`类提供了一种在后台执行工作并将结果返回到主线程的方式。然而，需要注意的是，对该类存在有效的批评意见。首先，最早的版本使用了`ThreadPoolExecutor`中的多个线程，但后来改为使用单个线程，而后又在后续版本中进行了反转。同样地，在`AsyncTask`的工作方法中无法中断任务的情况下，也没有办法中断任务。社区普遍认为，`AsyncTask`并没有提供足够的价值来弥补其缺点——作者们认为，在几乎所有情况下，前面描述的简单`Thread`和`post`方式更加简单、可靠和可控。

此章节中涉及的许多高级主题在安德斯·戈兰松（O’Reilly）的《*高效 Android 多线程*》中有详细介绍。当然，约书亚·布洛赫（O’Reilly）的《*高效 Java*》对各种专业水平的程序员都很有帮助。

# iOS

iOS 中的并发最好可以描述为根植于 C 语言的古典时代，同时通过 Grand Central Dispatch 的巧妙机制进行现代化。在应用程序中，开发者可能会看到主要有三种选项来在后台完成工作：`DispatchQueue`、`Operation`和`Thread`。

有时可以同时使用两者，但在本章节中，我们将专注于 Grand Central Dispatch 和`DispatchQueue`；尽管它们在 iOS 中略显低级，但它们由于简单和易于创建而被广泛使用。

## 在后台线程执行任务

那么在 iOS 中如何在后台执行工作呢？以下是一个简单的例子：

```
DispatchQueue.global().async {
    print("Do something")
}
```

第一行访问了 Grand Central Dispatch 中的全局后台工作队列，或者“GCD”。我们取得这个全局队列并在一个传入的闭包上调用`async`。第二行是该闭包的主体，仅在我们的简单例子中`print`了一行文本。

在 GCD 中完成操作有两个选项：异步和同步。同步调用可以使用`sync()`方法而不是`async()`，它们保证按照调用顺序执行。异步调用将在未来某个时候执行，对其具体时间几乎没有可见性。

说实话，前面的代码对大多数调用已足够，但通常需要对特定后台操作的优先级有更多控制。这可以通过类似以下的代码实现：

```
DispatchQueue.global(qos: .userInitiated).async {
    print("Do something")
}
```

新的参数被传递给之前的`global()`方法，命名为`qos`。这个参数是一个枚举，映射到 iOS 内的一组执行优先级。可用的不同选项包括：

`userInteractive`

最高优先级，用于与用户交互的操作。这里运行缓慢的操作会导致用户界面冻结。

`userInitiated`

优先级略低，并且比`userInteractive`更常用于后台工作。官方上，这是用户启动的操作，需要快速得到结果。

`default`

执行没有服务质量（QoS）的工作的默认级别。不建议开发者直接指定它。

`utility`

低于`default`的优先级，用于某些仍面向用户的实用类型操作，比如在应用程序中下载书籍或视频。

`background`

最低优先级的操作。这项工作对用户不可见。

`unspecified`

系统意图推断 QoS 应该是什么。很可能，你不应该使用这个。

###### 注意

这些质量级别也与性能和能效水平相关联。在`userInteractive`级别执行的工作性能更高，但能效较低。在`background`服务级别执行的工作性能不如前者，但更节能。

在我们之前的例子中，我们传入了`userInitiated`，表示操作应该在全局队列中以较高优先级在主线程外执行。

质量服务规则是定制全局调度队列可用的唯一方式之一。但是，还有另一种定制级别：

```
let queue = DispatchQueue(
    label: "com.oreilly.nativeappdevelopment", qos: .background, attributes: [.concurrent])
queue.async {
    print("Do something")
}
```

在此示例中，我们首先创建了自己的 `DispatchQueue` 实例。每个调度队列都需要一个唯一的标签。苹果建议默认使用反向 DNS 风格的标签，但只要提供的标签是唯一的，那就足够了。在我们的示例中，我们传入了一个 `qos` 值为 `background`，这意味着此队列中的操作将以最低优先级运行。

此外，我们已在 `attributes` 参数内传入了 `.concurrent` 选项。这样做意味着我们传递到队列中的每个操作或闭包都将并发运行。全局调度队列的默认值是 `.concurrent`。而自定义调度队列则相反，它们默认不会并发运行。

我们将这个新的调度队列存储在 `queue` 变量中。接下来的一行代码将使用 `queue` 对象调用与前面示例中相同的 `async(_:)` 方法，来执行一些代码。

## 在后台线程上完成的工作结果，在主线程上执行操作

现在，我们展示了如何在后台线程上执行操作。但有时您需要回到主线程执行一些重要的工作。在 iOS 上，每当 UI 需要更新时，通常会看到这种情况，因为所有 UI 工作都发生在主线程中。

在 iOS 上很容易返回到主线程：

```
DispatchQueue.main.async {
    // Update the UI
}
```

注意 `DispatchQueue` 上的 `main` 属性。这是一个共享队列，在运行循环中所有 UI 对象操作的地方。UI 的任何更新都需要像这样调用。例如，使用 `URLSessionDataTask` 进行网络调用后，可能需要向 UI 提供一些更新的信息。以下代码完成了这个任务：

```
let url = URL(string: "https://www.example.com")!
let task = URLSession.shared.dataTask(with: url) { (data, response, error) in
    // Handle errors, etc.

    guard let data = data, let string = String(data: data, encoding: .utf8) else {
        print("No data returned.")
        return
    }

    DispatchQueue.main.async {
		// Update UI
    }
}
task.resume()
```

不过，在不深入解释 `URLSession` 在 iOS 中的工作原理的情况下（请参阅第九章），请注意完成处理程序的主体中的 `DispatchQueue.main.async(_:)` 调用。这可以用于更新标签中的文本，更改 UI，或者只是为了简单的数据同步而跳转到主线程。

###### 注意

取消 GCD 操作并不是一件容易的事情。通常建议，如果您需要可取消的操作，请切换到使用带有 `OperationQueue` 的 `Operation` 对象。但这超出了本章的范围。可以查阅苹果关于 `Operation` 和 `OperationQueue` 的开发者文档。

# 我们所学到的

并发操作可能因并发编程而变得异常复杂，远远超出了简短的示例代码的范围。由于并发编程而存在的错误类别。

+   Android 有几种方法可以运行并发操作，但 `Thread` 是其中最常用和标准的方法之一，用于控制正在运行的操作。

+   GCD 通过一个方便的调度库提供了一种调度方式，通过它，iOS（和 macOS）应用程序可以利用并发编程。

+   在 Android 和 iOS 平台上，确保主线程不被阻塞是非常重要的。如果阻塞主线程，用户界面会出现卡顿或看起来像是锁死，这会给用户带来负面体验。

我们还发现在代码中有一些地方后台线程是非常有用的，比如网络代码。既然我们已经学会如何在应用程序的后台启动操作，那么在下一章中让我们更深入地了解 Android 和 iOS 中的网络通信。
