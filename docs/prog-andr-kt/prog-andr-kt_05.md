# 第五章：线程安全性

随着 Java 5 中*java.util.concurrent*包的引入，线程成为提高复杂应用程序性能的常用工具。在图形（或*头部*）应用程序中，通过减少处理信息以呈现*视图*（用户可以在屏幕上看到和交互的编程组件）的主线程负载，它们提高了响应能力。当在具有主线程或 UI 线程概念的程序中创建线程时，它被称为*后台线程*。这些后台线程经常接收和处理用户交互事件，如手势和文本输入；或其他形式的数据检索，如从服务器读取；或本地存储，如数据库或文件系统。在服务器端，使用线程的后端应用程序通过利用现代 CPU 的多个核心获得更好的吞吐量。

然而，使用线程也有其自身的风险，正如您将在本章中看到的那样。线程安全性可以被看作是一组技术和良好实践，以规避这些风险。这些技术包括*同步*、*互斥锁*和*阻塞*与*非阻塞*。像线程封闭等更高级的概念也非常重要。

本章的目标是介绍一些重要的线程安全概念，这些概念将在接下来的章节中使用。然而，我们不会广泛涵盖线程安全性。例如，我们不会解释*对象发布*或提供 Java 内存模型的详细信息。这些都是我们鼓励您在理解本章中解释的概念之后学习的高级主题。

# 一个线程问题的示例

要理解什么是线程安全性，我们将选择一个简单的线程安全问题的例子。当程序同时运行多个线程时，每个线程都有可能与其他正在运行的线程*同时*执行操作。但这并不一定会发生。当发生时，您需要防止一个线程访问正在被另一个线程修改的对象，因为它可能会读取对象的不一致状态。同样适用于同时的修改。确保只有一个线程可以同时访问一段代码块称为*互斥*。例如，考虑以下内容：

```
class A {
    var aList: MutableList<Int> = ArrayList()
    private set

    fun add() {
        val last = aList.last()  // equivalent of aList[aList.size - 1]
        aList.add(last + 1)
    }

    init {
        aList.add(1)
    }
}
```

`add()`方法获取列表的最后一个元素，将其加 1，并将结果追加到列表中。如果两个线程同时尝试执行`add()`，预期的行为将会是什么？

当第一个线程引用最后一个元素时，另一个线程可能已经有时间执行整个`aList.add(last + 1)`行。^(1) 在这种情况下，第一个线程读取最后一个元素为 2，并将 3 追加到列表中。结果列表将是`[1, 2, 3]`。还有另一种可能的情况。如果第二个线程没有时间追加新值，那么两个线程将读取最后一个元素的相同值。假设其余执行没有问题，我们得到结果`[1, 2, 2]`。还可能发生一种更危险的情况：如果两个线程正好同时尝试将新元素追加到列表中，则会抛出`ArrayIndexOutOfBoundsException`。

根据线程的交错情况，结果可能会有所不同。不能保证我们能得到任何结果。这些都是不线程安全的类或函数的症状，当从多个线程访问时可能不会正确运行。

那么，我们该如何修复这个潜在的错误行为呢？我们有三个选择：

1.  不要在线程之间共享状态。

1.  在线程之间共享不可变状态。

1.  修改我们的实现，以便多个线程可以使用我们的类并获得可预测的结果。

处理某种线程安全的多种策略，每种策略都有其优势和注意事项，因此开发人员必须能够评估他们的选择，并选择最适合线程问题需求的选项。

第一个选项相对明显。当线程可以处理完全独立的数据集时，没有访问相同内存地址的风险。

第二个选项是使用不可变对象和集合。不可变性是设计健壮系统的一种非常有效的方式。如果一个线程无法改变对象，则根本没有风险从另一个线程读取不一致的状态。在我们的例子中，我们可以使列表不可变，但是线程将无法向其追加元素。这并不意味着这个原则不能在这里应用。事实上，它可以——但我们稍后会回到这一章。我们必须提到使用不可变性可能存在的潜在缺点。从本质上讲，由于对象复制，它需要更多的内存。例如，每当一个线程需要处理另一个线程的状态时，都会执行状态对象的复制。如果重复进行并且速度很快，不可变性可能会增加内存占用——这可能是一个问题（特别是在 Android 上）。

第三种选项可以描述为：“执行`add`方法的任何线程都会在其他线程的后续`add`访问之前发生。”换句话说，`add`访问是串行进行的，没有交错。如果你的实现强制执行了上述声明，那么就不会有线程安全问题——该类被称为线程安全的。在并发世界中，前述声明被称为*不变量*。

# 不变量

要正确地使一个类或一组类成为线程安全的，我们必须定义不变量。不变量是一个始终为真的断言。无论线程如何调度，不变量都不应被违反。在我们的例子中，可以这样表达（从线程的角度来看）：

> 当我执行`add`方法时，我获取列表的最后一个元素，并且当我将其追加到列表中时，我确保插入的元素比前一个元素大 1。

从数学上讲，我们可以写成：

<math alttext="l i s t left-bracket n right-bracket equals l i s t left-bracket n minus 1 right-bracket plus 1" display="block"><mrow><mi>l</mi> <mi>i</mi> <mi>s</mi> <mi>t</mi> <mo>[</mo> <mi>n</mi> <mo>]</mo> <mo>=</mo> <mi>l</mi> <mi>i</mi> <mi>s</mi> <mi>t</mi> <mo>[</mo> <mi>n</mi> <mo>-</mo> <mn>1</mn> <mo>]</mo> <mo>+</mo> <mn>1</mn></mrow></math>

从一开始我们就看到我们的类不是线程安全的。现在我们可以这样说，因为在多线程环境中执行时，不变量有时会被违反，或者我们的程序会崩溃。

那么，我们可以做些什么来强制执行我们的不变量呢？实际上，这是一个复杂的问题，但我们将涵盖一些最常见的技术：

+   互斥锁

+   线程安全集合

## 互斥锁

互斥锁允许您防止对状态的并发访问，这个状态可以是一个代码块或者只是一个对象。这种互斥也称为*synchronization*。称为*mutex*或*lock*的`Object`保证了当它被一个线程拿走时，没有其他线程可以进入由此锁守护的区域。当一个线程试图获取另一个线程持有的锁时，它会被阻塞——直到锁被释放为止，它无法继续执行。这种机制相对容易使用，这也是开发人员在面对这种情况时经常采取的应对措施。不幸的是，这也像是打开了潘多拉魔盒，会引发死锁、竞态条件等问题。由于不正确的同步可能引发的问题太多，超出了本书的范围。然而，稍后在本书中我们将讨论其中一些，比如通信顺序进程中的死锁。

## 线程安全集合

线程安全集合是可以在多个线程访问时保持其状态一致的集合。`Collections.synchronizedList`是使`List`线程安全的一个有用方法。它返回一个`List`，该`List`包装对作为参数传递的`List`的访问，并使用内部锁调节并发访问。

乍一看，它看起来很有趣。因此，你可能会被诱惑使用它：

```
class A {
    var list =
        Collections.synchronizedList<Int>(object : ArrayList<Int?>() {
            init {
                add(1)
            }
        })

    fun add() {
        val last = list.last()
        list.add(last + 1)
    }
}
```

作为记录，这是 Java 中的等价物：

```
class A {
    List<Integer> list = Collections.synchronizedList(
        new ArrayList<Integer>() {{
           add(1);
        }}
    );

    void add() {
        Integer last = list.get(list.size() - 1);
        list.add(last + 1);
    }
}
```

这两种实现都存在问题。你能找出来吗？

###### 注意

我们也可以将列表声明为：

```
var list: List<Int> = CopyOnWriteArrayList(listOf(1))
```

在 Java 中，它的等价物是：

```
List<Integer> list = new CopyOnWriteArrayList<>(Arrays.asList(1));
```

`CopyOnWriteArrayList` 是 `ArrayList` 的一个线程安全实现，在这个实现中，所有的改变操作如 `add` 和 `set` 都通过创建底层数组的新副本来实现。线程 *A* 可以安全地遍历列表。如果与此同时，线程 *B* 向列表添加一个元素，则会创建一个新的副本，只对线程 *B* 可见。这本身并不使得这个类线程安全——因为 `add` 和 `set` 是由锁保护的。这种数据结构在我们更频繁地迭代它而不是修改它时非常有用，因为复制整个底层数组可能代价太高。注意，还有一个 `CopyOnWriteArraySet`，它只是 `Set` 的实现而不是 `List` 的实现。

虽然我们确实解决了并发访问问题，但我们的类仍然不符合我们的不变量。在测试环境中，我们创建了两个线程并启动它们。每个线程在我们类的同一个实例上执行一次 `add()` 方法。第一次运行测试后，当这两个线程完成它们的工作时，结果的列表是 `[1, 2, 3]`。有趣的是，我们多次运行相同的测试，有时结果是 `[1, 2, 2]`。这是由于前面展示的确切原因导致的：当一个线程执行 `add()` 内的第一行时，另一个线程可以在第一个线程继续执行其余部分之前执行整个 `add()` 方法。看到同步问题有多么隐蔽：看起来很好，但我们的程序却是有问题的。即使在一个微不足道的示例上，我们也很容易搞错。

一个正确的解决方案是：

```
class A {
    val list: MutableList<Int> = mutableListOf(1)

    @Synchronized
    fun add() {
        val last = list.last()
        list.add(last + 1)
    }
}
```

可能看到 Java 等价的会有所帮助：

```
public class A {
    private List<Integer> list = new ArrayList<Integer>() {{
        add(1);
    }};

    synchronized void add() {
        Integer last = list.get(list.size() - 1);
        list.add(last + 1);
    }
}
```

正如你所看到的，我们实际上并不需要同步列表。相反，`add()` 方法应该被同步。现在当一个线程首次执行 `add()` 方法时，另一个线程尝试执行 `add()` 时会被阻塞，直到第一个线程离开 `add()` 方法。没有两个线程同时执行 `add()`。这样不变量就被尊重了。

这个示例展示了一个类在内部使用线程安全的集合，但本身并不是线程安全的情况。当一个类或者代码是线程安全的时候，它的不变量从未被违反。这些不变量以及如何根据创建者的要求使用类，定义了一个明确的策略，应该在 javadoc 中清晰地表达出来。

###### 注意

这是 Java 内置的强制互斥机制。一个同步块由一个锁和一段代码块组成。在 Java 中，每个 `Object` 都可以用作锁。一个同步方法是一个其锁是类实例的同步块。当一个线程进入同步块时，它会获取锁。当线程离开块时，它释放锁。

还要注意，`add` 方法可以声明为使用 `synchronized` 语句的形式：

```
void add() {
    synchronized(this) {
        val last = list.last()
        list.add(last + 1)
    }
}
```

一个线程无法进入已经被另一个线程获取了的同步块。因此，当一个线程进入同步方法时，它会阻止其他线程执行任何同步方法或由此（也称为*内部*锁）保护的代码块。

# 线程限制

确保线程安全的另一种方法是确保只有一个线程拥有状态。如果状态对其他线程不可见，则根本不会出现并发问题的风险。例如，一个类的公共变量（其使用意图为线程限制到主线程）可能是错误的潜在来源，因为开发人员（不知道此线程策略）可能在另一个线程中使用变量。

线程限制的直接好处是简单性。例如，如果我们遵循每个`View`类型类应仅从主线程使用的约定，则可以避免在代码各处同步。但这是有代价的。客户端代码的正确性现在取决于使用我们代码的开发人员。在 Android 中，正如我们在上一章中看到的，应仅从 UI 线程操作视图。这是一种线程限制的形式——只要不违反规则，就不应出现涉及 UI 相关对象的并发访问问题。

另一个值得注意的线程限制形式是`ThreadLocal`。`ThreadLocal`实例可以看作是某个对象的提供者。该提供者确保对象的给定实例在每个线程中是唯一的。换句话说，每个线程都拥有自己的值的实例。使用示例如下：

```
private val myConnection =
        object : ThreadLocal<Connection>() {
            override fun initialValue(): Connection? {
                return DriverManager.getConnection(connectionStr)
            }
        }
```

常与不线程安全的 JDBC 连接一起使用，`ThreadLocal`确保每个线程将使用自己的 JDBC 连接。

# 线程争用

线程之间的同步很困难，因为可能会出现许多问题。我们刚刚看到了潜在的线程安全问题。还有一个可能影响性能的危险是*线程争用*，我们鼓励所有程序员都熟悉这一点。考虑以下例子：

```
class WorkerPool {
    private val workLock = Any() // In Java, we would have used `new Object()`

    fun work() {
        synchronized(workLock) {
            try {
                Thread.sleep(1000) // simulate CPU-intensive task
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }
    }

    // other methods which may use the intrinsic lock
}
```

因此，我们有一个`WorkerPool`，它以这样的方式控制由工作线程完成的工作，以至于一次只能有一个工作线程在`work`方法内部执行真正的工作。当实际工作涉及使用非线程安全对象并且开发人员决定使用这种锁定策略时，您可能会遇到这种情况。专门为`work`方法创建了一个专用锁，而不是在`this`上同步，因为现在工作线程可以调用其他方法而无需互斥。这也是为什么锁以相关方法命名的原因。

如果启动了多个工作线程并调用此`work`方法，则它们将竞争相同的锁。最终，根据线程的交替执行，一个工作线程因为另一个工作线程已经获取了锁而被阻塞。如果等待锁的时间远远小于其余执行时间，这不是问题。如果情况不是这样，则存在线程争用。线程大部分时间都在等待其他线程。然后操作系统可能会主动暂停一些线程，以便处于等待状态的其他线程可以恢复执行，这使得情况变得更糟，因为线程之间的上下文切换并不是免费的。当频繁发生时，可能会导致性能影响。

作为开发者，您应该始终避免线程争用，因为它可能会迅速降低吞吐量，并且会影响超出受影响线程的后果，因为上下文切换的速率可能会增加，这本身就会影响整体性能。

避免这种情况的最有效方法之一是避免阻塞调用，这将在下一节中解释。

# 阻塞调用与非阻塞调用

到目前为止，我们知道当一个线程试图获取另一个线程持有的锁时，该线程可能会被阻塞。导致线程被阻塞的函数称为*阻塞调用*。即使锁可能会立即被获取，调用可能会潜在地阻塞也使其成为一个`阻塞调用`的案例。但这只是一个特例。实际上有另外两种方式来阻塞线程。第一种是运行 CPU 密集型计算，这也被称为*CPU 绑定*任务。第二种是等待硬件响应。例如，当网络请求导致调用线程等待远程服务器的响应时，我们称之为 IO 绑定任务。^(2)

使调用快速返回的所有其他操作都被视为*非阻塞*。

当您准备进行阻塞调用时，应避免从主线程（也称为 UI 线程，在 Android 上）进行。^(3) 这是因为此线程运行处理触摸事件和所有与 UI 相关的任务如动画的事件循环。如果主线程重复被阻塞并超过几毫秒的持续时间，将会影响响应性，这是导致 Android“应用程序无响应”（ANR）错误的原因。

非阻塞调用是响应式应用程序的一个构建模块。现在，您需要识别利用这种技术的模式。工作队列是其中之一，在本书中我们将遇到各种形式的工作队列。

###### 注意

在大多数情况下，*同步* 和 *异步* 这两个术语分别被用作 *阻塞* 和 *非阻塞* 的同义词。虽然它们在概念上是相近的概念，但例如，异步与非阻塞的使用取决于上下文。异步调用通常涉及回调的概念，而这对于非阻塞调用并非必要。

# 工作队列

线程间通信，尤其是从一个线程向另一个线程提交工作，在 Android 中被广泛使用。这是 *生产者-消费者* 设计模式的一种实现。在线程中应用这一模式时，生产者是生成需要由消费者线程进一步处理的数据的线程。与直接通过共享可变状态让生产者与消费者直接交互不同，在它们之间使用队列来入队由生产者生成的工作。这种方式将生产者与消费者解耦，但这不是它的唯一好处，我们将会看到更多。通常，`Queue` 以 FIFO（先进先出）的方式运作。^(4)

从语义上讲，将 `Queue` 想象成一个电影院观众的排队。当第一位观众到达时，他们排在队列的最前面。每位额外的观众都排在最后。当开放门户并允许观众进入时，队列中的第一人先入场，然后是下一个，依此类推，直到整个 `Queue` 清空。

生产者将对象放在队列的头部，消费者从队列的尾部弹出对象。`put` 方法可能是一个阻塞调用，但如果可以证明大部分时间它实际上不会阻塞（即使阻塞时也是短暂的），那么我们就有了一种非常有效的方式，可以以非阻塞的方式（从生产者的角度来看）将工作从生产者转移到消费者，如图 5-1 所示。

在实践中，入队的对象通常是由后台线程提交的 `Runnable` 实例，并由主线程处理。此外，这不限于一个生产者和一个消费者。多个生产者可以并发地向队列提交工作，多个消费者可以从队列中取出工作。这意味着队列必须是线程安全的。^(5)

![pawk 0501](img/pawk_0501.png)

###### 图 5-1\. 生产者-消费者。

###### 注意

不要混淆 `Queue` 和 `Stack`，后者使用 LIFO（后进先出）而不是 FIFO。

从语义上来说，让我们把 `Stack` 想象成一叠煎饼。当厨房做更多煎饼时，它们会放在栈的顶部。当食客吃煎饼时，他们也是从栈的顶部拿走的。

# 回压

现在想象一下，我们的生产者比消费者快得多。工作对象会在队列中积累起来。如果队列恰好是无界的，我们会冒着耗尽内存资源和潜在不可恢复异常的风险：应用程序可能会崩溃。这种不仅对用户体验不佳，而且在这种未处理的错误中，你几乎可以肯定会丢失存在的任何状态信息。除非你非常注意并且对此情况做出反应，否则可能会出现突然终止，而没有机会执行通常会执行的任何清理。在 Android 中，当 Bitmap 实例不再被使用时，可以使用 recycle 方法将每个底层内存分配标记为不可达并且有资格进行垃圾收集。在一个混乱的系统退出中，你可能没有机会这样做，并且可能会有泄漏数据的风险。

在这种情况下，使用有界队列是一个明智的选择。但是当队列已满并且生产者尝试`put`一个对象时应该发生什么？

我们将在使用协程时再回到这个问题，但现在我们只讨论线程，答案是：它应该阻塞生产者线程，直到消费者从队列中至少取出一个对象。虽然这种阻塞应该作为设计的一部分，并预见到可能导致用户到达程序中这一点的任何情况或逻辑分支。虽然阻塞线程似乎有害，但阻塞的生产者允许消费者赶上并释放足够的空间到队列中，以便释放生产者。

这种机制被称为*回压*——无法跟上传入数据的数据消费者减慢数据生产者的能力。这是设计强大系统的非常有效的方法。[示例 5-1](https://example.org/back_pressure_example_id)展示了回压的实现方式。

##### 示例 5-1\. 回压示例

```
fun main() {
    val workQueue = LinkedBlockingQueue<Int>(5)  // queue of size 5

    val producer = thread {
        while (true) {
            /* Inserts one element at the tail of the queue,
 * waiting if necessary for space to become available. */
            workQueue.put(1)
            println("Producer added a new element to the queue")
        }
    }

    val consumer = thread {
        while (true) {
            // We have a slow consumer - it sleeps at each iteration
            Thread.sleep(1000)
            workQueue.take()
            println("Consumer took an element out of the queue")
        }
    }
}
```

自从 Java 7 以来，专门用于此目的的队列家族是`BlockingQueue`——它是一个接口，实现从单端队列`LinkedBlockingQueue`到双端队列`LinkedBlockingDequeue`（还存在其他实现）。[示例 5-1](https://example.org/back_pressure_example_id)的输出如下：

```
Producer added a new element to the queue
Producer added a new element to the queue
Producer added a new element to the queue
Producer added a new element to the queue
Producer added a new element to the queue
Consumer took an element out of the queue
Producer added a new element to the queue
Consumer took an element out of the queue
Producer added a new element to the queue
...
```

您可以看到，生产者很快用五个元素填充了队列。然后，在第六次尝试添加新元素时，由于队列已满，它被阻塞。一秒钟后，消费者从队列中取出一个元素，释放了生产者，现在可以添加一个新元素。此时队列已满。生产者尝试添加新元素，但再次被阻塞。再过一秒，消费者再次取出一个元素——依此类推。

需要注意的是，向`BlockingQueue`插入元素并不一定会阻塞。如果使用`put`方法，则在队列满时会阻塞。由于`put`可能会阻塞，我们说这是一个阻塞调用。然而，还有另一种方法可以添加新元素：`offer`，它尝试立即添加新元素并返回一个布尔值——操作是否成功。由于`offer`方法不会阻塞底层线程，并且仅在队列满时返回 false，我们说`offer`是非阻塞的。

如果我们在示例 5-1 中使用了`offer`而不是`put`，那么生产者将永远不会被阻塞，并且输出将会被填充`Producer added a new element to the queue`。根本不会有任何背压 - 切记不要这样做！

`offer`方法在可以承受丢失工作或者阻塞生产者线程不合适的情况下非常有用。当从队列中取出对象时，使用`take`和`poll`同样适用，它们分别是阻塞和非阻塞的。

相反地，如果消费者比生产者更快，那么队列最终会变为空。在`BlockingQueue`的情况下，使用消费者端的`take`方法将会阻塞，直到生产者在队列中添加新元素。因此，在这种情况下，消费者会放慢速度以匹配生产者的速率。

# 总结

+   当类或代码被称为线程安全时，它的不变性从不会被违反。因此，线程安全总是指一个应该在类的 javadoc 中明确定义的策略。

+   一个类可以在内部使用线程安全的数据结构，但自身并不是线程安全的。

+   尽量避免或减少线程争用。线程争用通常是糟糕的锁定策略的后果。降低这种风险的有效方法是尽可能使用非阻塞调用。

+   工作队列是一个模式，你经常会在 Android 和其他平台（如后端服务）中遇到。它简化了生产者（如 UI 线程）将任务移交给消费者（后台线程）的方式。消费者在能够时处理任务。任务完成后，消费者可以使用另一个工作队列将其工作结果发送回原始生产者。

+   有界的`BlockingQueue`在其已满时会阻塞`put`操作。因此，生产者速度过快会最终被阻塞，这为消费者赶上提供了机会。这是背压的一种实现，它有一个主要的缺点：生产者线程可能会被阻塞。有没有可能在不阻塞生产者线程的情况下实现背压？是的——我们将在第九章中看到这一点。

^(1) 实际上，线程的交错可以发生在字节码的行之间，而不仅仅是在普通 Java 行之间。

^(2) IO 操作并不一定是阻塞的。非阻塞 IO 存在，尽管它要复杂得多才能理解。Android 链接足够友好，当您在主线程上执行 HTTP 请求时会提醒您，但其他 IO 任务——如读取文件或查询数据库——则不会。如果在极其深思熟虑和小心的监督下进行，这甚至可能是一种故意且被接受的做法；虽然可能，但这应该是标准的罕见例外。

^(3) 即使对于工作线程，执行像处理 800 万像素图片这样的长时间任务，那些阻塞调用可能会阻塞 UI 正在等待的任务包。

^(4) 虽然并非所有工作队列都使用这种数据结构排列。一些更复杂的例子，如 Android 的 `MessageQueue`。

^(5) 即使只有一个生产者和一个消费者，队列也必须是线程安全的。
